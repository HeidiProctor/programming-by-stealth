# PBS 102 of X â€” Introducing Git

In the previous instalment we introduced the concept of version control systems (VCS), and we described the two broad categories they fall into â€” client-server, and peer-to-peer or distributed. We explained why we'd be focusing on distributed version control in this series, and why I chose to explore those concepts using Git. We also laid out a big-picture roadmap for this series-within-a-series, starting with local repositories, then private remote repositories for backup and easy access, and finally shared repositories for collaboration.

In this instalment we're going to focus on the underlying design of Git â€” what does it actually store, how does it represent it, and what words does it use to describe it. Trying to learn the Git commands, or even to use a Git GUI without an understanding of Git Jargon is a recipe for confusion and frustration! I want to nip that in the bud by laying a strong foundation we can then build on.

PLAYER GOES HERE

Before we get serious, let's take a moment to look at the name *Git*, does it mean anything? The short answer is *'not really'*. It's not an acronym, hence it not being all uppercase, and it's author, Linux Torvalds likes to say it can mean what ever you want it to mean, or what ever fits your current mood.

In Irish and British English a *git* is an *unpleasant person* (that's a little understated), and it's author joked:

> I'm an egotistical bastard, and I name all my projects after myself. First 'Linux', now 'git'.

The `git` command's man page describes Git as *the stupid content tracker*.

The README file that ships with the Git source code offers a collection of different definitions to match your mood:

* random three-letter combination that is pronounceable, and not actually used by any common UNIX command. The fact that it is a mispronunciation of *get* may or may not be relevant.
* stupid. contemptible and despicable. simple. Take your pick from the dictionary of slang.
* *global information tracker*: you're in a good mood, and it actually works for you. Angels sing, and a light suddenly fills the room.
* *"goddamn idiotic truckload of shit"*: when it breaks

Where ever the name comes from, no one seems too previous about it, which is a nice change in the world of nerdery, where something as innocuous as expressing a preference for `vi` over `emacs` can kick off a vicious troll war!

## A Git Repository

A Git Repository contains the full version history of a single project along with all its related metadata, and some configuration parameters.

Git repositories are designed to be quickly and efficiently copied, or *cloned* to use the Git jargon. When you clone a git repository the full history and all the metadata get copied, but the configuration parameters don't. This is important, because those configuration parameters are what allow you to personalise your copy of a repository. They hold information like your name, email address, and the remote copies of the repository you want to collaborate with.

On your computer, a Git repository is simply a folder with a well defined structure.

Conceptually, a Git repository consists of a number of parts, some permanent, others not.

1. **The Database** â€” the collection of objects that represents the entire committed version history of a project. This database is stored in a hidden folder named `.git` at the repository's root.
2. **The Working Copy** â€” the current state of the project, basically the visible content of the respositor 
3. **The Index** â€” a temporary data structure that represents the changes between the last committed version and the current working copy. The index keeps track of information about the changes you are making, and is used to build a version of your project for storage in the database when you *commit* some of all of your changes.

## The Git Database

The Git database stores the entire history of a project as a collection of objects, and these object come in just four types:

1. **Blobs** â€” a blob is basically the contents of a file.
2. **Trees** â€” a tree is analogous to a folder in a traditional file system. A tree object maps names to blobs and other tree objects. The recursive nature of that definition allows for an effectively infinite folder depth.
3. **Commits** â€” a commit represents a point in time in a project's history, a snapshot if you will. A commit uses a tree object to capture the state of all the files and folders in the project. As well as this tree a commit also contains metadata, like the author, the date, and an optional message describing the changes. 
4. **Tags** â€” tags are used to assign human-friendly names to other objects, usually commits.

All Git's more complex structures are simply collections of blobs, trees, commits, and tags.

Also, with our programming hat on we notice many *has-a* relationships here. Trees have blobs, commits have a tree, and tags have a commit.

### It's SHA1 Hashes All The Way Down

Within the Git database, objects don't have names, instead, they are always referenced by the SHA1 hash of their contents. Notice I described a blob as representing the contents of a file, not a file. What's the difference? Files have names, blobs don't! Trees map names to blobs and other trees, and it does so by storing name-value pairs where the names are the human-friendly file names, and the values are the SHA1 hashes of the blobs and the trees those names refer to.

This use of hashes to reference all objects gives Git inhered de-duplication. If you add the same file to your repository with multiple names and include it in multiple commits it will only ever be stored once within the Git database as a single blob that is referenced from many tree objects.

As you use Git you'll see SHA1 hashes all over the place.

### Git Stores it all

Many version control systems work by storing a single original copy of each file and a collection of changes, or *deltas*. You can re-construct any version of any file by starting with the original and applying each delta one after the other. This is very efficient in terms of storage, but computationally complex, and only works on text files.

Git takes a completely different approach â€” it stores every version of every file in its entirety. This is a much more robust approach, and allows Git to version absolutely anything. You might think this approach would make Git be a real disk space hog, but don't worry, it's not. We've already mentioned that Git uses SHA1 hashes to avoid duplication, but Git does a lot more than that, including compression and some extremely clever storage algorithms.


## The Index, Staging, and Stashes

The index exists to help you transition your changes into commits. With many version control systems it's an all-or-nothing thing â€” you check out the code, make changes, and then check all those changes in. Git is different â€” you can mark individual changes for inclusion in the next commit, leaving other changes un-committed.

Git describes this process as *staging*, so a change that has not yet been marked for inclusion in the next commit is an *un-staged change*, and and a change that has been marked for inclusion in the next commit is said to be *staged*. 

When I first moved from SVN to Git I found this extra step extremely annoying â€” I'd always committed everything, and it was just one simple action, so I have to stage and then commit, that's twice the work! Experience has corrected that initial error of judgement ðŸ™‚

The ability to commit only some of your changes, or, to split your changes across multiple well named commits is very powerful â€” it leads to better organised repositories that are easier to use. With SVN I would end up with commits with messages like *"Fixed a typo in the docs, fixed a bug in function a() and aded function b()"*. With Git I can use staging to easily break that into three distinct commits, each capturing just one conceptual change â€” *"fixed typo in docs"*, *"fixed bug in function a()"*, and *"added function b()"*.

It also means that if I have to leave in a hurry and have only gotten the typo fixed and am still working on debugging function a() I can commit the typo and leave the rest in staging so I can continue where I left off when I get back.

The index also allows changes to be temporarily set aside for later though a feature called *stashing*. I like to think of a stash as a temporary commit that only I can see. The most common time to need to stash something is when I'm working on something and the phone suddenly rings I have to drop everything to fix a major bug in some other part of the codebase. I simply stash what ever I was doing, fix the bug, commit that change, and then un-stash what I was working on before and continue where I left off.

## Installing Git

Git is available on all major platforms, and you generally have multiple options for each platform. The Official docs are a good starting point: TO DO

Personally, these are my preferences:

* **Mac:** use the XCode commandline tools
* **Linux:** use the version from my distribution's default package manger (`yum install git` on RHEL & CentOS)
* **Windows:** use the Linux Subsystem for Windows